> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/m0_74756975/article/details/136203209)

一. Shell 命令及原理
--------------

[Linux 操作系统](https://so.csdn.net/so/search?q=Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&spm=1001.2101.3001.7020)狭义上是 Linux 内核，广义上是指 Linux 内核 + Linux 外壳 (Shell) 和对应的配套程序

[Linux](https://so.csdn.net/so/search?q=Linux&spm=1001.2101.3001.7020) 外壳：Linux 外壳是用户与内核之间的接口，用户通过外壳与操作系统进行交互和操作。在 Linux 系统中，用户可以选择不同的外壳，比如常见的 Bash、Zsh 等。

配套程序： 工具程序和应用程序，用于完成各种任务，比如文件管理、网络通信、[系统](https://so.csdn.net/so/search?q=%E7%B3%BB%E7%BB%9F&spm=1001.2101.3001.7020)配置等。这些配套程序一起构成了一个完整的操作系统。

什么是 Shell？  

Shell 是命令行解释器是外壳程序，作用有两个 1) 将用户的**命令解析**并**传给 Linux 内核** 2)[Linux 内核](https://so.csdn.net/so/search?q=Linux%E5%86%85%E6%A0%B8&spm=1001.2101.3001.7020)将命令执行完后，Shell 将接执行结果返还给用户 windows 下的外壳程序就是图形化界面

Shell 如何执行的？(后面会详细讲)

1.  **用户输入命令：** 用户在 Shell 提供的命令行界面中输入命令，比如 `ls`（列出目录内容）、`cd`（切换目录）等。
    
2.  **解析命令：** Shell 解析用户输入的命令，并根据命令的语法和结构进行解析，确定命令的名称、参数和选项等信息。
    
3.  **查找命令：** Shell 在系统的路径（PATH）中查找用户输入的命令对应的可执行文件。系统会按照 PATH 中的顺序依次查找，找到后就可以执行该命令。
    
4.  **创建子进程：** 如果找到了要执行的命令，Shell 会创建一个子进程来执行该命令。这样可以保持 Shell 进程和要执行的命令进程的独立性，互不干扰。
    
5.  **加载程序：** 子进程加载命令对应的可执行文件到内存中，准备执行。
    
6.  **执行程序：** 子进程开始执行加载到内存中的程序，按照用户输入的命令参数和选项进行相应的操作。
    
7.  **等待命令执行完成：** Shell 父进程会等待子进程执行完毕，并获取子进程的执行结果，然后显示给用户。
    
8.  **返回结果：** 最终，Shell 将命令执行的结果输出到屏幕上供用户查看。                                   
    

Shell 是外壳总称，不同的系统有不同的 shell，Centos7 的 Shell 是 bash，windows 下的就是图形化界面

说完了关于 Shell 的原理那为什么要有 Shell 呢？

用户在用 Linux 操作系统时，是不会直接对操作系统进行使用，就是通过 Shell，因为操作系统是非常复杂的东西，一般人不经过深度学习是无法直接使用操作系统，所以就有了 Shell 外壳程序，降低了技术门槛，简化了成本

二. 权限
-----

### **2.1： 权限的概念**

root：超级用户（基本不受权限的约束）  
普通用户：我们新建的用户（受权限约束）  
（Linux 中所有的用户都要有密码，无论是 root 还是其他，即便是多个普通用户，也要设置密码，建议设置不同密码）

adduser：创建新用户

在 root 用户下，使用 `useradd` 命令创建新用户：在终端中输入以下命令，用 `useradd` 命令创建新用户。比如，创建一个名为 `newuser` 的新用户：

```
chmod u+w /home/abc.txt
chmod o-x /home/abc.txt
```

设置新用户的密码：使用 `passwd` 命令为新用户设置密码，输入以下命令并按照提示设置密码：

```
[root@localhost ~] chmod +t /home/ # 加上粘滞位
[root@localhost ~] ls -ld /home/
drwxrwxrwt. 3 root root 4096 9月 19 16:00 /home/
[root@localhost ~] su - litao
[litao@localhost ~] rm /home/abc.c #litao不能删除别人的文件
rm：是否删除有写保护的普通空文件 "/home/abc.c"？y
rm: 无法删除"/home/abc.c": 不允许的操作
```

 (可选) 设置新用户的家目录和其他属性：如果需要设置新用户的家目录、Shell 类型等其他属性，可以使用 `useradd` 命令的参数来指定。比如，设置新用户的家目录为:/home/newuser                      

```
usermod -aG sudo newuser
```

 sudo command：对一条指令进行暂时提权，以 root 的身份运行（目前我们用 adduser 新建的用户没有颁发执行 sudo，系统不信任你，除非未来将普通用户添加到系统的信任列表里）

### **2.2Linux 权限管理**

#### **2.2.00. Linux** **下有两种用户：超级用户（****root****）、普通用户。**

超级用户：可以再 linux 系统下做任何事情，不受限制

普通用户：在 linux 下做有限的事情。

超级用户的命令提示符是 “#” ，普通用户的命令提示符是 “$” 。

**命令** ： su [ 用户名 ]

**功能** ：切换用户。

例如，要从 root 用户切换到普通用户 user ，则使用 su user 。 要从普通用户 user 切换到 root 用户则使用 su root（ root 可以省略），此时系统会提示输入 root 用户的口令。

su + 用户名 vs  su - + 用户名 （ 二者区别是什么？)

1.  `su +用户名`：使用 `su +用户名` 的方式进行切换用户时，并不会改变当前环境变量，即当前用户的环境变量（如 PATH、HOME 等）会继续保留。这样可能导致一些权限或者路径等方面的问题，因为切换后的用户环境变量并未加载。
    
2.  `su - +用户名`：使用 `su - +用户名` 的方式进行切换用户时，会以切换后的用户的身份完全登录到一个新的 shell 会话中，同时加载新用户的环境变量，包括 HOME 目录、PATH 等。这样可以确保切换后的操作环境和权限与目标用户一致，避免出现一些意想不到的问题
    

#### **2.2.01.** **文件访问者的分类（人）**

文件和文件目录的所有者： u---User （用户本身）

文件和文件目录的所有者所在的组的用户： g---Group （所属组）

其它用户： o---Others （其他人)

**2.2.02.** **文件类型和访问权限（事物属性）**

![](https://img-blog.csdnimg.cn/direct/52ac1d2307534640b7003cb384d9ceb1.png)

![](https://img-blog.csdnimg.cn/direct/6e595650c4454962911595f3dd94da59.png)

为什么要有所属组？

为了更好地管理用户和文件的访问权限，管理员也可以创建其他组，并将用户添加到这些组中，以提供不同的访问权限。例如，管理员可以创建一个 `dev` 组，将所有开发人员添加到该组中，以便他们可以访问和修改需要开发的文件和目录。举个例子 a,b,c 三个人。a 写了一份代码不想让 c 看到，但想让 b 看到，a 就可以把 b 拉进自己的所属组，打开所属组的权限，关闭 oher 的权限就可以了。

Linux 操作系统中文件名后缀没有直接的意义那为什么还要规范 Linux 下的文件后缀？

1). 规范后缀，方便用户辨认文件类别

2). Linux 上安装的 gcc 是一款编译器软件，需要区分后缀，如果是一个 txt 文件，编译器是不能对这种文件编译的，其他 Linux 系统上运行的其他软件也需要区分后缀

a) **文件类型**         d：文件夹         -：普通文件         l：软链接（类似 Windows 的快捷方式）         b：块设备文件（例如硬盘、光驱等）         p：管道文件         c：字符设备文件（例如屏幕等串口设备）         s：套接口文件 b) **基本权限**         i. 读（ r/4 ）： Read 对文件而言，具有读取文件内容的权限；对目录来说，具有浏览该目录信息的权限         ii. 写（w/2 ）： Write 对文件而言，具有修改文件内容的权限；对目录来说具有删除移动目录内文件的权限         iii. 执行（ x/1 ）： execute 对文件而言，具有执行文件的权限；对目录来说，具有进入目录的权限         iv.“—” 表示不具有该项权限

#### **2.2.03.** **文件权限值的表示方法**

a) 字符表示方法<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>Linux 表示</td><td>说明</td><td>Linux 表示</td><td>说明</td></tr><tr><td>r--</td><td>只读</td><td>-w-</td><td>只写</td></tr><tr><td>--x</td><td>仅可执行</td><td>rw-</td><td>可读可写</td></tr><tr><td>-wx</td><td>可写可执行</td><td>r-x</td><td>可读可执行</td></tr><tr><td>rwx</td><td>读写执行</td><td>- - -</td><td>无权限</td></tr></tbody></table>b)8 进制数值表示方法<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>权限符号 (读写执行)</td><td>八进制</td><td>二进制</td></tr><tr><td>r</td><td>4</td><td>100</td></tr><tr><td>w</td><td>2</td><td>010</td></tr><tr><td>x</td><td>1</td><td>001</td></tr><tr><td>rw</td><td>6</td><td>110</td></tr><tr><td>rx</td><td>5</td><td>101</td></tr><tr><td>wx</td><td>3</td><td>011</td></tr><tr><td>rwx</td><td>7</td><td>111</td></tr><tr><td>- - -</td><td>0</td><td>000</td></tr></tbody></table>

#### **2.2.04.** **文件访问权限的相关设置方法**

**a)chmod** **功能：** 设置文件的访问权限 **格式：** chmod [ 参数 ] 权限 文件名 **常用选项：** R -> 递归修改目录文件的权限 说明：只有文件的拥有者和 root 才可以改变文件的权限 _chmod_ ① 用户表示符 +/-= 权限字符 +: 向权限范围增加权限代号所表示的权限 -: 向权限范围取消权限代号所表示的权限 =: 向权限范围赋予权限代号所表示的权限 用户符号：   u ：拥有者 g ：拥有者同组用 o ：其它用户 a ：所有用户 **实例：**

```
chmod u+w /home/abc.txt
chmod o-x /home/abc.txt
```

②三位 8 进制数字 **实例：**

```
chmod 664 /home/abc.txt
```

**b)chown**

**功能** ：修改文件的拥有者 **格式** ： chown [ 参数 ] 用户名 文件名 **c)chgrp** **功能** ：修改文件或目录的所属组 **格式** ： chgrp [ 参数 ] 用户组名 文件名 **常用选项** ： -R 递归修改文件或目录的所属组 **d)umask** **功能** ： 查看或修改文件掩码 新建文件夹默认权限 = 0666  新建目录默认权限 = 0777 但实际上你所创建的文件和目录，看到的权限往往不是上面这个值。原因就是创建文件或目录的时候还要受到 umask 的影响。假设默认权限是 mask ，则实际创建的出来的文件权限是 : mask&~umask **格式** ： umask 权限值 **说明** ：将现有的存取权限减去权限掩码后，即可产生建立文件时预设权限。超级用户默认掩码值为 0022 ，普通用 户默认为 0002 。 **file** **指令：** **功能说明** ：辨识文件类型。 **语法** ： file [ 选项 ] 文件或目录 ...  **常用选项** ： -c 详细显示指令执行过程，便于排错或分析程序执行的情形。 -z 尝试去解读压缩文件的内容。 **目录的权限** 可执行权限 : 如果目录没有可执行权限 , 则无法 cd 到目录中 . 可读权限 : 如果目录没有可读权限 , 则无法用 ls 等命令查看目录中的文件内容 . 可写权限 : 如果目录没有可写权限 , 则无法在目录中创建文件 , 也无法在目录中删除文件 . **粘滞位** 当一个目录被设置为 " 粘滞位 "( 用 chmod +t), 则该目录下的文件只能由 一、超级管理员删除 二、该目录的所有者删除 三、该文件的所有者删除

```
[root@localhost ~] chmod +t /home/ # 加上粘滞位
[root@localhost ~] ls -ld /home/
drwxrwxrwt. 3 root root 4096 9月 19 16:00 /home/
[root@localhost ~] su - litao
[litao@localhost ~] rm /home/abc.c #litao不能删除别人的文件
rm：是否删除有写保护的普通空文件 "/home/abc.c"？y
rm: 无法删除"/home/abc.c": 不允许的操作
```

**三. 关于权限的总结**
--------------

**1).** 目录的可执行权限是表示你可否在目录下执行命令。 **2).** 如果目录没有 -x 权限，则无法对目录执行任何命令，甚至无法 cd 进入目 , 即使目录仍然有 -r 读权限（这个地方很容易犯错，认为有读权限就可以进入目录读取目录下的文件） **3).** 而如果目录具有 - x 权限，但没有 -r 权限，则用户可以执行命令，可以 cd 进入目录。但由于没有目录的读权限 **4).** 所以在目录下，即使可以执行 ls 命令，但仍然没有权限读出目录下的文档。