> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/qq_38798840/article/details/127292822)

#### 目录

*   [一、keyExchange](#keyExchange_1)
*   *   [1. 原题](#1_2)
    *   [2. 考察知识点与解题思路](#2_38)
    *   *   [Diffie-Hellman 密钥交换](#DiffieHellman_39)
    *   [3. 解题脚本](#3_54)
*   [二、Prof. Shamir's Secret](#Prof_Shamirs_Secret_72)
*   *   [1. 原题](#1_73)
    *   [2. 考察知识点与解题思路](#2_103)
    *   *   [Shamir 门限方案](#Shamir__104)
    *   [3. 解题脚本](#3_114)

一、keyExchange
-------------

### 1. 原题

题目给出的是题目给出的是加密过程和输出：

```
from secret import flag, gb, g, p, Diffie_Hellman_KEY_EXCHANGE
from Crypto.Util.number import *
from base64 import b64encode
from Crypto.Cipher import AES
from hashlib import md5
from Crypto.Util.Padding import pad

plaintext = pad(flag, 16)

a = getRandomNBitInteger(1024)
shared = Diffie_Hellman_KEY_EXCHANGE(a) # the original one, not the elliptic curve version!!!!
key = md5(str(shared).encode()).digest()

cipher = AES.new(key, AES.MODE_ECB)
ciphertext = cipher.encrypt(plaintext)

print(f'师傅给你送了一个flag')
print(f'加密的flag = {b64encode(ciphertext)}')
print(f'p = {p}')
print(f'your secret key {a}')
print(f'g = {g}')
print(f'师傅的公钥 = {gb}')
```

可以从加密过程的说明脚本中看出，输出的信息有：经过 **AES 加密后**又 **base64 编码**的 flag（所以解 AES 前要先解码 base64 呀）、p、g、我方私钥 a 和师傅的[公钥](https://so.csdn.net/so/search?q=%E5%85%AC%E9%92%A5&spm=1001.2101.3001.7020) gb：

```
师傅给你送了一个flag
加密的flag = b'w8OCrexPPqnv2hR+xKeHhXIp0Blp1DYCV4LeZeeLpv5MzUL71raTOeOs4SQBySHH'
p = 133448764119399847876731592238604881175769007976799828874328988761588128500145459082023001027383524831194316266946485380737147372837136403065060245135035225976604193830121124575947440188318348815263642243784574567832213775382081426762862856428888257126982268557543952549848053225651398101391048467656128070913
your secret key 141940531741414073502483547551457269459744373002985569536254444581939073930343975447649087549033350166772929396986965301002444997704537487577508504709368627174241095027876996113941220579274986994026832534664179333669861059196192190040046004398523932288881838011696679341328520530265002776147308306715042734185
g = 3
师傅的公钥 = 89434791765835058026108803508194156525355359465406829253856379139334424137549915669535243140614128105195584073112084994777148895681804127886440617684648237403345873311011154293855911891719204975035914932661810961867593769891076834656437254428353814290948181922438812745384577094827728409350756648446941874382
```

### 2. 考察知识点与解题思路

#### Diffie-Hellman 密钥交换

具体的理论知识可参考博客：http://t.csdn.cn/fjnn8  
Diffie-Hellman 算法可以**使两个用户之间安全地交换一个密钥，但不能用于加密或解密信息**。（但这里感觉也不能说 “安全” 因为无法抵御中间人攻击？  
为了方便思路与代码对照，我还是说一下理论知识和思路。  
在题目中都是已知的 g 和 p，分别是算法中的底数 g 和模数 p。

> 设有两个要交换密钥（公钥）的用户 A 和用户 B  
> 用户 A 的私钥是 a，计算 g^a mod p = AKey，AKey 是用户 A 要发送给用户 B 的公钥  
> 用户 B 的私钥是 b，计算 g^b mod p = BKey，BKey 是用户 B 要发送给用户 A 的公钥  
> 用户 A 拿到 B 发来的 BKey 后，计算 BKey^a mod p=key，用户 B 拿到用户 A 发来的 AKey 后，计算 AKey^b mod p=key，这二者的值应该是相同的 key，也就是两人协商出的密钥。

**现在根据题目已经已知了我方私钥 a、对方公钥 BKey、模数 p，已经可以直接计算 BKey^a mod p 得到双方协商出的密钥 key（脚本中命名为 shared）。**  
然后根据题目脚本中 key = md5(str(shared).encode()).digest()，要将 shared 转 str、encode 后再做 md5 得到 AES 加密用的密钥 key，就原样复制这条语句到解密脚本中即可。  
再根据之前对题目脚本中输出内容的分析，对密文形式的 flag 先做 base64 解码。  
最后用密钥 key 解密 AES 得到明文 flag。

### 3. 解题脚本

```
import base64
import hashlib
from Crypto.Cipher import AES

a=141940531741414073502483547551457269459744373002985569536254444581939073930343975447649087549033350166772929396986965301002444997704537487577508504709368627174241095027876996113941220579274986994026832534664179333669861059196192190040046004398523932288881838011696679341328520530265002776147308306715042734185
p=133448764119399847876731592238604881175769007976799828874328988761588128500145459082023001027383524831194316266946485380737147372837136403065060245135035225976604193830121124575947440188318348815263642243784574567832213775382081426762862856428888257126982268557543952549848053225651398101391048467656128070913
BKey=89434791765835058026108803508194156525355359465406829253856379139334424137549915669535243140614128105195584073112084994777148895681804127886440617684648237403345873311011154293855911891719204975035914932661810961867593769891076834656437254428353814290948181922438812745384577094827728409350756648446941874382
shared=pow(BKey,a,p)
key = hashlib.md5(str(shared).encode()).digest() #key=b'\xaep\x1f\xb5\x04\x9b.\x94\xd2:C\x1a\xd4<,\xce'
flag=b'w8OCrexPPqnv2hR+xKeHhXIp0Blp1DYCV4LeZeeLpv5MzUL71raTOeOs4SQBySHH'
flag=base64.b64decode(flag)  #先解码base64
cipher = AES.new(key, AES.MODE_ECB)
flag=cipher.decrypt(flag)  #对base64解码后的密文做AES解密
print(flag)
```

flag: flag{d1ff1e_h311m4n_is_4_p13c3_0f_c4k3}

二、Prof. Shamir’s Secret
-----------------------

### 1. 原题

题目给出的是加密过程和输出：

```
from Crypto.Util.number import *
from secret import flag
a = getPrime(256)
b = getPrime(256)
c = getPrime(256)
d = bytes_to_long(flag)
n = getStrongPrime(2048)

def poly(x):
    return (a * x ** 3 + b * x ** 2 + c * x + d) % n

for _ in range(4):
    x = getRandomNBitInteger(256)
    print(f'({x}, {poly(x)})')

print(n)
```

从脚本可以看出，输出的是循环中的 4 个 (x 值, 当前 x 对应的 poly(x) 的计算值)和 n：

```
(107156592202708719207677242145785380370925248573491581679548864240229105117413, 130345771647598884054430192964980389494531690916321281560051538057910945565624075918097771618618910263287152864051564635195578796179646674192491555857366963976329072793625649841007238934532144994966695961491116944111900519450656607199501654544809304677384301432194356761274376314501143216649135187625964931902)
(90629424458637844580841178302065768114471702341586161908858665404968070428143, 78858394764644720845979385422903377630845158220853604360871859882044655577246282808874532941560824773914594412415345616068416548364923695233972936176087206729847544516343237888024173952758718279163069742944961359652574962129434781851767007643037433981750489254639449637677610354746497770492254725894119193662)
(100626477579781167218124067468465940736522526684796828200460725563611057086831, 107938673826832098883774065383352754899611421173786919174851524067358319831595518533880365335333592351382030254987030861475878447430100862628809476494215295084769705787398168068863060859122952000010558086859754975554734850230223040925027217057055876423229204027280075168615462165634569977166298865366648414270)
(93935717805931479760310332373603550626215862380271563609987050092246456803681, 87807687834883656794449107852803757931909462710953942209358337840912886376275257864214018767300085688088981183791568376874906785193974861264511995029891797395218085734556515485224508250678274640400740193260888803386269425525930551167801371074041851406813322268615707951973495879968706624649318162995708734670)
```

### 2. 考察知识点与解题思路

#### Shamir 门限方案

关于 **Shamir 门限**的理论知识可以参考博客：http://t.csdn.cn/wvS1Z  
我就是从这里学到的 O(∩_∩)O  
放到这题大概就是：  
1）有秘密藏在了多项式里，**想恢复出秘密需要 “多项式的次数 + 1” 个子密钥**，这里的 “多项式次数 + 1” 就是“**门限**”，子密钥即多项式的计算值 f(x)，**这里是三次多项式，又已知了 4 个 x 和 4 个多项式的计算结果**，模数 n 也已知，所以可以解题。  
2）将已知条件代入，利用公式计算出结果转成 bytes 输出即是 flag。  
解密公式：  
![](https://img-blog.csdnimg.cn/c357a9a2a6b849318ad12a1492e330fe.png)  
ps: **公式中的 p，在题目中对应的是 n，f(i) 即 poly(x) 的值**  
对应到题目，有 k=4，在累加项中，j 取 1~4，f(i) 取 f(x1)~f(x4)，f(i) 后面累乘项的**分子**是用 x(**这里 x 就是字母 x 本身！**) 分别减去除当前的 **x 值** (注意是 “值”，指 x1/x2/x3/x4 中的某一个) **之外的 3 个 x 值**，**分母**是用当前 **x 值**减去除当前的 **x 值** (指 x1/x2/x3/x4 中的某一个) **之外的 3 个 x 值**。将 4 组运算结果累加，得到的多项式中的**字母 x 取 0**（即只保留常数项），最后再去**模大数 n**。

### 3. 解题脚本

在我的脚本中，x1~x4 表示已知的 4 个 x，rm1~rm4 代表的是 x 对应的 poly(x) 的计算值，**因为分子上有三个 (x-i) 项相乘所以得到的常数项符号位负**，所以要在最前面手动添一个负号，对于分母的计算，是对模数 n 求**乘法逆元**。

```
import gmpy2
import libnum

x1=107156592202708719207677242145785380370925248573491581679548864240229105117413
rm1=130345771647598884054430192964980389494531690916321281560051538057910945565624075918097771618618910263287152864051564635195578796179646674192491555857366963976329072793625649841007238934532144994966695961491116944111900519450656607199501654544809304677384301432194356761274376314501143216649135187625964931902

x2=90629424458637844580841178302065768114471702341586161908858665404968070428143
rm2=78858394764644720845979385422903377630845158220853604360871859882044655577246282808874532941560824773914594412415345616068416548364923695233972936176087206729847544516343237888024173952758718279163069742944961359652574962129434781851767007643037433981750489254639449637677610354746497770492254725894119193662

x3=100626477579781167218124067468465940736522526684796828200460725563611057086831
rm3=107938673826832098883774065383352754899611421173786919174851524067358319831595518533880365335333592351382030254987030861475878447430100862628809476494215295084769705787398168068863060859122952000010558086859754975554734850230223040925027217057055876423229204027280075168615462165634569977166298865366648414270

x4=93935717805931479760310332373603550626215862380271563609987050092246456803681
rm4=87807687834883656794449107852803757931909462710953942209358337840912886376275257864214018767300085688088981183791568376874906785193974861264511995029891797395218085734556515485224508250678274640400740193260888803386269425525930551167801371074041851406813322268615707951973495879968706624649318162995708734670

n=31332583438236375592937719796184754941510418106758544436807128579095975774977164550965999210436423180868482749439792419270701760326867558983833590368116755394302102816558834270767750410927007254951332459412016857259923960095221831744199277859298274645778838122123090174549834537459028702418645316659860963695912411044490603690484176741018002722235584411422885336520840416125528921196994346534698226763483608314982898155320734426983215291745003213365884087604024203316024824786079501166114638727651689476288442288919373885358425210859822108037791909364199015379638899887715692181883916583183449343868694265742569597579

m1=-rm1*x2*x3*x4*gmpy2.invert((x1-x2)*(x1-x3)*(x1-x4),n)
m2=-rm2*x1*x3*x4*gmpy2.invert((x2-x1)*(x2-x3)*(x2-x4),n)
m3=-rm3*x1*x2*x4*gmpy2.invert((x3-x1)*(x3-x2)*(x3-x4),n)
m4=-rm4*x1*x2*x3*gmpy2.invert((x4-x1)*(x4-x2)*(x4-x3),n)

m=(m1+m2+m3+m4)%n
print(libnum.n2s(int(m)))
```

运行脚本可以直接得到 flag。  
flag: flag{w0w_y0u_k0nw_sham1r_s3cret_5h4r1ng_4nd_1agrange_interpolation!!!}

在别人的博客上看到的另一种解法但没看懂，先记录一下：[参考来源](https://blog.csdn.net/zerorzeror/article/details/127167383?ops_request_misc=&request_id=&biz_id=102&utm_term=newstarctf%20week3%20crypto&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-127167383.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&spm=1018.2226.3001.4187)

```
import gmpy2
import libnum

x1=107156592202708719207677242145785380370925248573491581679548864240229105117413
rm1=130345771647598884054430192964980389494531690916321281560051538057910945565624075918097771618618910263287152864051564635195578796179646674192491555857366963976329072793625649841007238934532144994966695961491116944111900519450656607199501654544809304677384301432194356761274376314501143216649135187625964931902

x2=90629424458637844580841178302065768114471702341586161908858665404968070428143
rm2=78858394764644720845979385422903377630845158220853604360871859882044655577246282808874532941560824773914594412415345616068416548364923695233972936176087206729847544516343237888024173952758718279163069742944961359652574962129434781851767007643037433981750489254639449637677610354746497770492254725894119193662

x3=100626477579781167218124067468465940736522526684796828200460725563611057086831
rm3=107938673826832098883774065383352754899611421173786919174851524067358319831595518533880365335333592351382030254987030861475878447430100862628809476494215295084769705787398168068863060859122952000010558086859754975554734850230223040925027217057055876423229204027280075168615462165634569977166298865366648414270

x4=93935717805931479760310332373603550626215862380271563609987050092246456803681
rm4=87807687834883656794449107852803757931909462710953942209358337840912886376275257864214018767300085688088981183791568376874906785193974861264511995029891797395218085734556515485224508250678274640400740193260888803386269425525930551167801371074041851406813322268615707951973495879968706624649318162995708734670

n=31332583438236375592937719796184754941510418106758544436807128579095975774977164550965999210436423180868482749439792419270701760326867558983833590368116755394302102816558834270767750410927007254951332459412016857259923960095221831744199277859298274645778838122123090174549834537459028702418645316659860963695912411044490603690484176741018002722235584411422885336520840416125528921196994346534698226763483608314982898155320734426983215291745003213365884087604024203316024824786079501166114638727651689476288442288919373885358425210859822108037791909364199015379638899887715692181883916583183449343868694265742569597579

def GCRT(x,rm):
    curx,currm=x[0],rm[0]
    for (xi,rmi) in zip(x[1:],rm[1:]):
        d=gmpy2.gcd(curx,xi)
        c=rmi-currm
        assert (c%d == 0)
        K=c // d *gmpy2.invert(curx//d,xi//d)
        currm+=curx*K
        curx=curx * xi // d
        currm %=curx
    return (currm % curx ,curx)

x=[x1,x2,x3,x4]
rm=[rm1,rm2,rm3,rm4]

s,aa=GCRT(x,rm)
s%=n
print(s)
print(libnum.n2s(int(s)))
```